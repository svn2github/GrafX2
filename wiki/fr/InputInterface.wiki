=GrafX2 - Les entrées=

==Get_input() (dans DIVERS.ASM):==
  * Touches :
    * Met à jour la variable "Touche", un mot 16-bits qui contient dans sa partie basse la valeur du scan-code (valeur plutôt liée à la géographie de la touche) de la touche enfoncée à traiter, et dans sa partie haute un codage des touches de contrôles enfoncées au moment de l'appel.
      * (Touche & 0x0100) => Shift
      * (Touche & 0x0200) => Control
      * (Touche &amp; 0x0400) => Alt
    * Met dans la variable "Touche_ASCII" la valeur ASCII (valeur liée au caractère que représente la touche) de la touche enfoncée à traiter.
    * Dans le cas où la variable globale "Autoriser_changement_de_couleur_pendant_operation" serait à 0, et qu'il existerait au moins une valeur dans la pile des opérations, la fonction filtre les touches. Cela signifie que l'on ne peut pas interrompre une opération en cours, sauf pour changer la couleur du pinceau si l'opération l'autorise (utile pour faire varier la couleur du pinceau à l'aide des touches pendant qu'on dessine).
  * Souris :
    * Met à jour la position (Mouse_X,Mouse_Y) de la souris en fonction de sa position dans un écran virtuel. Cet écran est volontairement plus grand que la résolution réelle du mode vidéo car de nombreux drivers ne fournissent pas la position de la souris au pixel près...
    * Met à jour l'état des boutons de la souris (Mouse_K). La variable vaut 0 si aucun bouton n'est enfoncé, 1 si seul le bouton gauche est enfoncé, et 2 si seul le bouton droit est enfoncé. Dans le cas où les 2 boutons seraient enfoncés, Get_input() considère qu'aucun bouton n'est enfoncé (Mouse_K = 0).
    * La fonction corrige la position de la souris afin de l'empêcher de sortir de la surface d'image sur laquelle elle se trouve si au moins une valeur est dans la pile des opérations (la souris ne sort pas de la zone de dessin tant que l'opération de dessin n'est pas terminée), et elle simule également le déplacement et les clics de la souris si la combinaison de touches courante correspond à de telles commandes. Dans ce dernier cas, la touche est ensuite filtrée afin d'éviter de faire travailler la fonction appelante pour rien.
    * Dans le cas où la souris change d'état ou que la variable globale "Forcer_affichage_curseur" est placée à 1, le curseur de la souris est réaffiché. La fonction laisse toujours la variable Forcer_affichage_curseur à 0 en fin d'appel.
    * La fonction fait appel à Calculer_coordonnees_pinceau() qui se charge de calculer convenablement les coordonnées du pinceau (Pinceau_X,Pinceau_Y) en fonction de la position de la souris à l'écran, de la position de la zone de dessin dans l'image, du facteur de zoom et de l'effet de la grille.

*Important :* Dans la plupart des cas, vous n'avez pas à appeler cette fonction car le moteur (boucle principale, gestionnaire de fenêtre, sélecteurs de fichier, ...) s'en est déjà chargé. Vous pouvez donc considérer que les variables concernées sont déjà à jour. Si vous appeliez vous-même la fonction Get_input() à un moment inoportun, certaines commandes de l'utilisateur, prises en compte par le moteur, ne seraient pas traitées.

==Attendre_fin_de_click() (dans DIVERS.ASM):==
S'il vous arrive d'avoir besoin de vous assurer que l'utilisateur n'appuie plus sur les boutons de la souris à un instant donné, cette fonction attend jusqu'à ce que l'utilisateur relache le bouton. La valeur de Mouse_K vaut alors 0, mais s'il a déplacé la souris avant de suspendre sa pression, la position (Mouse_X,Mouse_Y) n'est pas encore à jour. Cependant, cela ne devrait pas être génant (au pire, un appel à Get_input() mettra ces valeurs à jour).
