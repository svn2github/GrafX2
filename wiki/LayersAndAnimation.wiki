#summary Design of the new page management system to handle layers and animation.
#labels Developpers

= Introduction =

Two of the big features we plan to add in GrafX2, layers and animation, need a rewrite of the management of pages in the program. This page gather the ideas and possible designs and is open for discussion.

I somewhat mixed technical stuff with my notes on the user interface design. It seems a good idea to separate them.

= User interface overview =
The timeline is the main thing we create when we open a file. It is possible to render a specific frame to the screen. Rendering all the frame according to their timestamp will play the animation. Rendering only one frame allows to preview it. It is possible to switch between frame preview and layer edition. It is not possible to paint on a frame. We could use the splitscreen system of the zoomed view to display both the frame rendering (as the normal view) and the edited layer (as the zoomed view).

An animation is a set of frames arranged in a timeline. Each fram can have a different palette, so it is possible to use them to do simple palette cycling animations. They also hold a list of layers. Each layer is composed of two parts: picture data and distorsion information. Picture data is the real set of pixels. The same picture data can be used in multiple layers, either in multiple frames (this is what happen when you do palette cycling: the same pixels are dispayed over and over, with the same palette). The distorsion is the position, rotation, stretch and linear distorsion of the layer. It can be handled pretty much like the current "brush effects" screen. So you can have a part of your picture scrolling over the screen while rotating, if you want.

There is a thing that i'm not sure: should the spare page be also an animated timeline ? or should just it be a still frame with fixed layers ? or just a single page ?

= Architecture overview =

http://grafx2.googlecode.com/svn/wiki/pictures/devdoc/pages_class_diagram.png

At the top you see the current system.
At the bottom it's the new one.

= Notes =
We introduce three new structures: T_Timeline, T_Frame, and T_Layer, and we do some changes in the T_Page and T_List_of_page.

==T_Timeline==
Its a linked list of T_Frames, sorted by timestamp.
The T_Timeline holds the comment, filename, format and directory of the current edited file. It is possible to have only one T_Frame, one T_Layer and one T_Page to handle usual still picture files.

==T_Frame==
This holds the data for a frame: palette, timestamp, and a linked list of layers. The palette is stored here because it needs to be global to the frame (we allow 256 colors on screen at once, no more) and because this allows to display the same page with different palettes for palette cycling.

Of course the list of layers is ordered by Z-Order, from bottom to top, this allow easy rendering of the frame by simply rendering the layers in the order they come in the list.

==T_Layer==
This is the struc defining a layer. It holds a pointer to the picture data (this picture data can be used in multiple layers, in the same frame or in different successive frames). It also holds the transparent color number (this one can also be different for each occurence of the picture data) (maybe there should be multiple transparent colors ?), and finally, the distorsion is handled there simply by storing the screen pixel coordinates of the 4 corners of the layer. This allow to render any kind of distorsion using only the linear_distort function we have for brushes. However, it's pretty hard to generate this data by hand to make a proper rotation, so we will need a powerful way of generating them. We may want to store the parameters used for this generator (lets say, translation vector, rotation speed, zoom ratio, and simple offset for hand-distorsion of each of the 4 corners), allow the user to tweak them at any time to change his animation, then interpolate them to generate our distorsion points. This would then be some kind of keyframe you place at main points of the animation, while the other frames are interpolated from them.

==T_Page==
A T_Page holds a bunch of pixels with the width and height. It can be packed using some RLE and delta system to avoid wasting memory. However, I think all pages used in the animation should be depacked before playing. This can be done at the same time we generate interpolated frames from the keyframes, when you click the "render and play" button. The packing is particularly interesting for backup pages that, most of the time, are not used (particularly the old ones). Actually, the delta only make sense in the backup list because this animation system does not provide a way to have ordered pixel data to make an hand-drawn animation. If you do that, it's just a set of frames with different pages of the same size, the same palette, and the same distorsion everywhere. But the T_Pages does not know they are ordered in an animation. They can even be used in completely unrelated places and without animation (or in reverse order) at another place.

As a T_Page can be used in multiple layers, i think it makes sense to add some simple reference counting mechanism. Each time an object get a pointer to a page, it increments a counter. When the object is deleted or release its pointer in any way, it decrements the counter. When the counter reaches 0 the page could be deleted immediately. Or it could be kept in packed form in some kind of pagelist, allowing to use it later in another layer.

==T_List_of_pages==
This is used in the current backup system. I'm not sure how we should handle undo/redo with the animation. We can have a separate undo list for each T_Page, or for each T_Layer (allowing to undo distorsion changes too), or for each T_Frame (allownig to undo any change). If the undo list is at the T_Frame level, we'll be in trouble because we only need to store the layer that is actually changed. The delta+rle will make the other layers take very little space, so it can be a workaround in this scheme.

If the backup list is a list of frame, then it is possible to undo frame deletion, because we can push the frame back in the main list thanks to its timestamp.

=File format=
We will probably have to design our own format to store all of this in a convenient form. PKM can be extended for that using more/different chunks, not necessarily keeping compatibility and name, but using the same chunk system.
We will want to import palette cycling from neochrome and degas elite (maybe others), and to save/load gif animations. Maybe we can find infos on what other animation package such as Autodesk Animator Pro had (features, file format, ...)

Maybe vgapaint has some things too ?

=Use of animations=
Of course playing with animations is nice, but if they can't go out of the program, it's of little interest. Gif export is already a nice solution, but the ability to play your own format in another program directly would be really nice.
The idea is to provide a piece of code to render and play the animation in any program using SDL. In this context, another program could ask us to render a frame to an SDL screen, either with some content already in it, or just filled with magic pink for blitting later. The frame render should not touch the unused pixels, it should not fill the screen in black. It'd be really nice to be able to control the engine and use it to build simple games (let it load all the layers, but build the timeline in realtime depending on what the player does). But maybe i'm dreaming too much :). Rendering over a 24bit screen could also be a nice feature, in order to have a 24bit background and then simple layers in 256colors over it. Or a 3d game with some animation to make the ingame display. But, let's start with simple things :) 

----
=Comments by Yves:=

I've mostly thought about layers, which seem to be the more complicated compared to animation. I've had a long discussion with IlKke about the notion of "lock background", and it has given me ideas on how to handle drawing on top layer.

I don't understand what you mean with "frame preview and layer edition". I wanted to use the "classic" system I know from Photoshop: At any moment one layer is the one where you're painting, and all frames can be set on/off visually, independantly from each other. The program will perform fastest if only one layer is visible and edited, slightly slower if there are visible layers above it OR below, and slower if both (above and below). I don't think we need to let the user turn off the layer where he's painting, as he can't see what he's doing.

I would really prefer using only one color index, of user's choice, as transparent within the image. It will be transparent for us for all layers except the last visible layer, where the color shows. I know it's traditional for windows program to show a checkered pattern, but it's going to be slow for us and it's equally traditional for sprite artists to draw on "magic pink" or any color of the right luminance as the expected background that is clearly not  in their palette

Independantly from this, the user can still choose a "transparent color for GIF or PNG".

Different palette for each animation step: I don't like it very much, as it's quite painful to keep the palette consistent over the different frames, and I really doubt it's well-supported in GIF format (the specs says yes, but I've seen how web browser and Windows image editors don't support the specs for animation)

The way I see it, most editing actions modify only one layer of the current frame. Some actions DO modify several or all frames, like for example a resize. With a smart system of reference counting, we can point to the same pixel data (T_Page) for the different "editing steps" of layers that couldn't be affected by the operation. I find this idea critically important for performances, because on each action (brush stroke) we need to backup for the undo/redo system, and not having to duplicate a dozen of frames is going to be a lifesaver.

=plk=
There are two ways to use layers :
  * In a still picture, the photoshop way : this is what you are describing
  * In an animation, which is what I was thinking of when writing this page. In this case a layer is used as a sprite and can be stretched, rotated and distorted. But to draw on it, it is important to have an undistorted view. When working on an animation, we want to display only the active layer. When working on a still picture, we want to display all of them. Maybe the two modes are too different and incompatible, or maybe we can find a way to make them work together.

For the drawing, actually, we will have to have 3 things in memory:
  * A- The current layer
  * B- The rendering of all the other layers (both top and below)
  * A mask with 3 possible values : 0 = this pixel on screen is from a layer below (display from B, possible to draw over it), 1 = this pixel is from the current layer (display from A, possible to draw over it), and 2 = this pixel is from a layer above (display from B, not possible to draw over it).
This way you just have to check this table for <2 to know if you can draw. We can even use the values -1 (below, 0 (current) and 1 (above), which make it even easier to test (<=0 exists as a jump condition in assembly language) and maybe also makes more sense. We can even store the relative position of the layer in this table without any extra overhead.

About colors:
Again, one transparent color for all the picture makes sense in a still picture, but in an animation you may want to change the transparency of a layer overtime (to make it blink, for example). Actually, having a transparency bit for each color index in the palette would be the most powerful way.

Changing the palette per frame:
This is the most simple animation you can get. Neochrome and Degas elite have support for it, OCP Art Studio on the Amstrad CPC too. And it is important for creating good animations, I think. Fade in and out, and other palette cycling effects can make great things. The idea is not to change the whole palette at each frame, but to make 4 to 16 colors cycle in a loop to get simple animations. Rotating spiral, waterfalls, and other simple effects can be done with it.

I don't want to feel limited by any existing existing format, be it gif or any other one. We may render to .avi if needed :)

We have to define the goals for this animation system... for me it's meant to make animation sequences in game, providing a packed format and allowing to replay from any program using SDL. In this context there is no need to render to any format for external replaying. But there may be a lot of other uses.
We have to think more about the separation between animation and layers to have both working efficiently...